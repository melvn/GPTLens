[
    {
        "function_name": "transferProxy",
        "code": "function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt, uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){ if(balances[_from] < _feeSmt + _value) revert(); uint256 nonce = nonces[_from]; bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce); if(_from != ecrecover(h,_v,_r,_s)) revert(); if(balances[_to] + _value < balances[_to] || balances[msg.sender] + _feeSmt < balances[msg.sender]) revert(); balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeSmt; Transfer(_from, msg.sender, _feeSmt); balances[_from] -= _value + _feeSmt; nonces[_from] = nonce + 1; return true; }",
        "vulnerability": "Integer overflow in fee and value sum",
        "reason": "The function checks if `_from` has sufficient balance using `balances[_from] < _feeSmt + _value`, but does not account for integer overflow. An attacker can craft `_feeSmt` and `_value` such that their sum overflows to a lower value (e.g., `_feeSmt = 2^256 - 200`, `_value = 200`), causing the check to pass even if `_from` has insufficient balance. This allows the attacker to transfer large amounts of tokens they don't own and mint arbitrary tokens for `msg.sender` via overflow in `balances[msg.sender] += _feeSmt`.",
        "file_name": "2018-10376.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow in the transferProxy function of a smart contract implementation for SmartMesh (aka SMT), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets via crafted _fee and _value parameters, as exploited in the wild in April 2018, aka the \"proxyOverflow\" issue."
    },
    {
        "function_name": "allocateTokens",
        "code": "function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner { if(allocateEndTime < now) revert(); if(_owners.length != _values.length) revert(); for(uint256 i = 0; i < _owners.length ; i++){ address to = _owners[i]; uint256 value = _values[i]; if(totalSupply + value <= totalSupply || balances[to] + value <= balances[to]) revert(); totalSupply += value; balances[to] += value; } }",
        "vulnerability": "Unrestricted token minting by owner",
        "reason": "The `allocateTokens` function allows the owner to mint unlimited tokens within 1 day of deployment. There is no cap on `totalSupply`, so a malicious/compromised owner can inflate the supply indefinitely, devaluing existing tokens. Even though the function is time-limited, the 1-day window is sufficient to cause significant harm if exploited.",
        "file_name": "2018-10376.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow in the transferProxy function of a smart contract implementation for SmartMesh (aka SMT), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets via crafted _fee and _value parameters, as exploited in the wild in April 2018, aka the \"proxyOverflow\" issue."
    },
    {
        "function_name": "approveAndCallcode",
        "code": "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(_extraData)) { revert(); } return true; }",
        "vulnerability": "Reentrancy via arbitrary external call",
        "reason": "The function performs an external call (`_spender.call(_extraData)`) after setting an allowance. A malicious `_spender` can re-enter the contract (e.g., by calling `transferFrom` or `approveAndCallcode` again) before the allowance is consumed. This allows repeated draining of the allowance, as each reentrant call resets `allowed[msg.sender][_spender]` to `_value`.",
        "file_name": "2018-10376.sol",
        "label": "Integer Overflow",
        "description": "An integer overflow in the transferProxy function of a smart contract implementation for SmartMesh (aka SMT), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets via crafted _fee and _value parameters, as exploited in the wild in April 2018, aka the \"proxyOverflow\" issue."
    }
]