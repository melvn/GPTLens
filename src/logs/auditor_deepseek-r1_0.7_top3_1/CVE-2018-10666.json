[
    {
        "function_name": "setOwner",
        "code": "function setOwner(address _owner) returns (bool success) { owner = _owner; return true; }",
        "vulnerability": "Missing access control allows anyone to become owner",
        "reason": "The setOwner function lacks the onlyOwner modifier, allowing any caller to arbitrarily change the contract owner. This enables an attacker to take full control of the contract, including privileged functions like uploadBalances, setExportFee, or unlockToken. Once ownership is hijacked, the attacker can drain funds, manipulate fees, or disrupt the contract's operation.",
        "file_name": "2018-10666.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora IDEX Membership (IDXM), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. A new owner can subsequently modify variables."
    },
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint256 _amount) returns (bool success) { require(!locked); require(balanceOf[msg.sender] >= _amount); require(balanceOf[_to] + _amount >= balanceOf[_to]); balanceOf[msg.sender] -= _amount; uint256 preBalance = balanceOf[_to]; balanceOf[_to] += _amount; bool alreadyMax = preBalance >= singleIDXMQty; if (!alreadyMax) { if (now >= validAfter[_to].ts + mustHoldFor) validAfter[_to].last = preBalance; validAfter[_to].ts = now; } if (validAfter[msg.sender].last > balanceOf[msg.sender]) validAfter[msg.sender].last = balanceOf[msg.sender]; Transfer(msg.sender, _to, _amount); return true; }",
        "vulnerability": "Integer overflow/underflow due to unsafe arithmetic",
        "reason": "The transfer and transferFrom functions use raw arithmetic operations (e.g., balanceOf[msg.sender] -= _amount) without leveraging the inherited SafeMath library. In Solidity <0.8.0, this allows integer underflows/overflows. An attacker can send tokens they don\u2019t own (underflow to max uint256) or overflow a recipient\u2019s balance to near-zero. This directly compromises the token\u2019s integrity and enables theft or denial of service.",
        "file_name": "2018-10666.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora IDEX Membership (IDXM), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. A new owner can subsequently modify variables."
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _amount) returns (bool success) { require(!locked); allowance[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; }",
        "vulnerability": "Allowance front-running vulnerability",
        "reason": "The approve function does not enforce the check-effects-interaction pattern or require resetting allowances to zero before updating. Attackers can front-run a user\u2019s approval change (e.g., from 100 to 50) by first using the old allowance (100) before it\u2019s reduced. This allows double-spending of allowances, enabling unauthorized token transfers from the victim\u2019s balance.",
        "file_name": "2018-10666.sol",
        "label": "Access Control",
        "description": "The Owned smart contract implementation for Aurora IDEX Membership (IDXM), an Ethereum ERC20 token, allows attackers to acquire contract ownership because the setOwner function is declared as public. A new owner can subsequently modify variables."
    }
]