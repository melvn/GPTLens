[
    {
        "function_name": "luckyBuy",
        "code": "function luckyBuy() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_) return(true); else return(false); }",
        "vulnerability": "Insecure Pseudo-Randomness",
        "reason": "The 'luckyBuy' function uses block.timestamp, block.difficulty, block.coinbase, and other predictable on-chain data to generate randomness. Miners can manipulate these values to influence the outcome, allowing attackers to increase their chances of winning the Luckybuy prize. This makes the randomness exploitable and not truly random.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "win",
        "code": "function win() public { require(now > RoundTime[Round] && RoundTime[Round] != 0); RoundLastGreedyMan[Round].transfer(RoundETH[Round]); emit winnerEvent(RoundLastGreedyMan[Round], RoundETH[Round], Round); Round++; }",
        "vulnerability": "DoS via Failed Transfer",
        "reason": "The 'win' function uses transfer() to send ETH to RoundLastGreedyMan without handling potential failures. If the winner is a contract with a fallback function that reverts (e.g., due to gas limits or intentional sabotage), the transfer will fail, causing the entire transaction to revert. This prevents the round from incrementing, halting the contract indefinitely.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "buyHeart",
        "code": "function buyHeart(address referred) public payable { ... address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); ... }",
        "vulnerability": "Contract Call Bypass",
        "reason": "The 'buyHeart' function checks if the sender is a contract by checking extcodesize. However, during contract construction (constructor), extcodesize returns 0, allowing malicious contracts to bypass this check. Attackers can exploit this to automate purchases or manipulate the game logic, violating the 'humans only' requirement.",
        "file_name": "2018-17877.sol",
        "label": "Bad Randomness",
        "description": "A lottery smart contract implementation for Greedy 599, an Ethereum gambling game, generates a random value that is predictable via an external contract call. The developer used the extcodesize() function to prevent a malicious contract from being called, but the attacker can bypass it by writing the core code in the constructor of their exploit code. Therefore, it allows attackers to always win and get rewards."
    }
]