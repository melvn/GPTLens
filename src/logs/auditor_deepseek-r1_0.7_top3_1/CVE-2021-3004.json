[
    {
        "function_name": "_deposit",
        "code": "function _deposit(IERC20 token, uint amount) internal {\n    uint _value = LINK.getPriceUSD(address(token)) * amount / uint256(10)**token.decimals();\n    require(_value > 0, \"!value\");\n    (address _pair, uint amountA,) = _addLiquidity(address(token), address(this), amount, _value);\n    token.safeTransferFrom(msg.sender, _pair, amountA);\n    _mint(_pair, _value);\n    uint _liquidity = ISushiswapV2Pair(_pair).mint(address(this));\n    collateral[msg.sender][address(token)] += _liquidity;\n    collateralCredit[msg.sender][address(token)] += _value;\n    uint _fee = _value * FEE / BASE;\n    _mint(msg.sender, _value - _fee);\n    _mint(address(this), _fee);\n    notifyFeeAmount(_fee);\n    emit Deposit(msg.sender, address(token), _value, amount, _value);\n}",
        "vulnerability": "Oracle Price Manipulation",
        "reason": "The _deposit function calculates the deposited collateral value using a single oracle (LINK.getPriceUSD) without cross-verifying with the actual AMM pool price. If the oracle is manipulated or provides incorrect prices (e.g., due to stale data or centralized control), attackers can deposit undervalued assets to mint inflated yCREDIT tokens. This allows them to steal protocol funds by redeeming overvalued yCREDIT for legitimate collateral. This is a critical vulnerability as it directly affects the protocol's solvency.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    },
    {
        "function_name": "_addLiquidity",
        "code": "function _addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired ) internal virtual returns (address pair, uint amountA, uint amountB) {\n    pair = FACTORY.getPair(tokenA, tokenB);\n    if (pair == address(0)) {\n        pair = FACTORY.createPair(tokenA, tokenB);\n        pairs[pair] = true;\n        _markets.push(tokenA);\n    } else if (!pairs[pair]) {\n        pairs[pair] = true;\n        _markets.push(tokenA);\n    }\n    (uint reserveA, uint reserveB) = SushiswapV2Library.getReserves(address(FACTORY), tokenA, tokenB);\n    if (reserveA == 0 && reserveB == 0) {\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n        uint amountBOptimal = SushiswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal <= amountBDesired) {\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        } else {\n            uint amountAOptimal = SushiswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal <= amountADesired);\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        }\n    }\n}",
        "vulnerability": "Unrestricted Malicious Market Creation",
        "reason": "The _addLiquidity function automatically adds any token to the _markets list when a new Sushiswap pair is created. Attackers can exploit this by creating pairs with malicious tokens (e.g., tokens with manipulated supply or fake collateral). Combined with oracle manipulation, this allows attackers to deposit worthless tokens as collateral, mint yCREDIT, and drain the protocol. The system should restrict which tokens can be used as collateral instead of auto-adding all pairs.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    },
    {
        "function_name": "_transferTokens",
        "code": "function _transferTokens(address src, address dst, uint amount) internal {\n    balances[src] -= amount;\n    balances[dst] += amount;\n    emit Transfer(src, dst, amount);\n    if (pairs[src]) {\n        uint _fee = amount * FEE / BASE;\n        _transferTokens(dst, address(this), _fee);\n        notifyFeeAmount(_fee);\n    }\n}",
        "vulnerability": "Incorrect Fee Application Leading to Reward Distortion",
        "reason": "The fee mechanism applies a transfer tax when tokens are sent from a pair (e.g., during a buy). However, the fee is deducted from the recipient's (buyer's) balance after the initial transfer, which could lead to underflow if the fee rounds to zero or exceeds the received amount. Additionally, notifyFeeAmount recalculates rewardRate without proper validation, allowing attackers to manipulate reward distribution by making small transfers to trigger fee updates, potentially disrupting reward calculations or causing integer overflows/underflows.",
        "file_name": "2021-3004.sol",
        "label": "Wrong Logic",
        "description": "The _deposit function in the smart contract implementation for Stable Yield Credit (yCREDIT), an Ethereum token, has certain incorrect calculations. An attacker can obtain more yCREDIT tokens than they should."
    }
]