[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    if (_to != fights) {\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n    }\n    Transfer(_from, _to, _value);\n    return true;\n}",
        "vulnerability": "Unauthorized transfers to 'fights' address",
        "reason": "The transferFrom function does not check or deduct the allowance when transferring to the 'fights' address. This allows any user to transfer tokens from any account to the 'fights' address without requiring approval. An attacker can exploit this by setting 'fights' to a controlled address (if owner is compromised) or leveraging existing 'fights' access to drain funds from arbitrary accounts.",
        "file_name": "2018-17882.sol",
        "label": "Integer Overflow",
        "description": "An Integer overflow vulnerability exists in the batchTransfer function of a smart contract implementation for CryptoBotsBattle (CBTB), an Ethereum token. This vulnerability could be used by an attacker to create an arbitrary amount of tokens for any user."
    },
    {
        "function_name": "batchTransfer",
        "code": "function batchTransfer(address[] _to, uint _value) public {\n    balances[msg.sender] = safeSub(\n        balances[msg.sender],\n        _to.length * _value\n    );\n    for (uint i = 0; i < _to.length; i++) {\n        balances[_to[i]] = safeAdd(balances[_to[i]], _value);\n        Transfer(msg.sender, _to[i], _value);\n    }\n}",
        "vulnerability": "Integer overflow in multiplication",
        "reason": "The multiplication '_to.length * _value' in batchTransfer is vulnerable to integer overflow. An attacker can craft a large '_to.length' and '_value' such that the product overflows to a small value (e.g., 0). This allows them to bypass balance checks, deduct little/no tokens from their balance, while still crediting all recipients with '_value' tokens. This effectively mints tokens out of thin air.",
        "file_name": "2018-17882.sol",
        "label": "Integer Overflow",
        "description": "An Integer overflow vulnerability exists in the batchTransfer function of a smart contract implementation for CryptoBotsBattle (CBTB), an Ethereum token. This vulnerability could be used by an attacker to create an arbitrary amount of tokens for any user."
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    if (_to != fights) {\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n    }\n    Transfer(_from, _to], _value);\n    return true;\n}",
        "vulnerability": "Incorrect allowance handling order",
        "reason": "The transferFrom function updates balances before modifying allowances. While safe for non-fights addresses (due to revert on underflow), this violates the checks-effects-interactions pattern. If external calls were present, this could enable reentrancy. Though not directly exploitable here, it reflects poor security practices and increases risk if contract logic evolves.",
        "file_name": "2018-17882.sol",
        "label": "Integer Overflow",
        "description": "An Integer overflow vulnerability exists in the batchTransfer function of a smart contract implementation for CryptoBotsBattle (CBTB), an Ethereum token. This vulnerability could be used by an attacker to create an arbitrary amount of tokens for any user."
    }
]