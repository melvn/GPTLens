[
    {
        "function_name": "withdraw",
        "code": "function withdraw() public { require(worldOwner == msg.sender); lottoIndex += 1; numtickets = 0; totalBounty = 0; worldOwner.transfer(this.balance); }",
        "vulnerability": "Owner can steal funds mid-lottery",
        "reason": "The withdraw() function allows the owner to reset the lottery state (numtickets, totalBounty) and transfer the entire contract balance to themselves at any time, including during an active round. This enables the owner to steal all accumulated ticket funds from participants before the lottery completes. Participants who already bought tickets would lose their ETH without any reward distribution.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "PayWinner",
        "code": "function PayWinner( address winner ) private { require(numtickets == maxTickets); uint ownerTax = 6 * totalBounty / 100; uint winnerPrice = totalBounty - ownerTax; LottoComplete(msg.sender, lottoIndex, winnerPrice); lottoIndex += 1; numtickets = 0; totalBounty = 0; if(_direction == 0 && maxTickets < 20) maxTickets += 1; if(_direction == 1 && maxTickets > 10) maxTickets -= 1; if(_direction == 0 && maxTickets == 20) _direction = 1; if(_direction == 1 && maxTickets == 10) _direction = 0; worldOwner.transfer(ownerTax); winner.transfer(winnerPrice); }",
        "vulnerability": "DoS via failed winner transfer",
        "reason": "PayWinner uses transfer() to send funds to the winner. If the winner is a contract without a payable fallback function, the transfer will fail, reverting the entire transaction. This leaves the contract state (numtickets == maxTickets) unchanged, permanently blocking the AddTicket function (due to its numtickets < maxTickets check). Attackers can exploit this by purchasing the last ticket with a non-payable address to intentionally brick the contract.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "AddTicket",
        "code": "function AddTicket() public payable { require(msg.value == ticketPrice); require(numtickets < maxTickets); lastTicketTime = now; numtickets += 1; totalBounty += ticketPrice; bool success = numtickets == maxTickets; NewTicket(msg.sender, success); if(success) { PayWinner(msg.sender); } }",
        "vulnerability": "Predictable last-ticket winner selection",
        "reason": "The winner is deterministically set to the last address that submits a ticket when maxTickets is reached. Attackers can monitor the blockchain for pending transactions and front-run the final ticket purchase to guarantee they become the winner. This violates fair lottery mechanics and allows centralized exploitation by bots/MEV searchers.",
        "file_name": "2018-15552.sol",
        "label": "Bad Randomness",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    }
]