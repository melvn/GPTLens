[
    {
        "function_name": "transferFrom",
        "vulnerability": "Inverted Allowance Check & Underflow",
        "criticism": "The reasoning is correct. The inverted check allows transfers when allowance is insufficient, and the underflow (due to Solidity 0.4.2) sets the allowance to a massive value. This allows attackers to drain the victim's balance after one underflow. The severity is critical (direct theft) and profitability is extremely high. The code flaw is unambiguous and exploitable.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The condition `if( allowed[from][msg.sender] >= value ) return false;` is inverted. This allows transfers when the allowance is **insufficient** (allowed < value) instead of enforcing it. Furthermore, when `allowed[from][msg.sender]` is less than `value`, the line `allowed[from][msg.sender] -= value;` underflows (due to Solidity 0.4.2's lack of overflow checks), setting the allowance to a massive value (2^256 - X). Attackers can exploit this to gain infinite approval after one underflow, enabling unlimited token transfers from the victim's account.",
        "code": "function transferFrom(address from, address to, uint value) returns (bool success) { if (frozenAccount[msg.sender]) return false; if(balances[from] < value) return false; if( allowed[from][msg.sender] >= value ) return false; if(balances[to] + value < balances[to]) return false; balances[from] -= value; allowed[from][msg.sender] -= value; balances[to] += value; Transfer(from, to, value); return true; }",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "transferFrom",
        "vulnerability": "Incorrect Frozen Account Check",
        "criticism": "The reasoning is accurate. The check on `msg.sender` (spender) instead of `from` (token owner) allows transfers from frozen accounts via approved spenders. Severity is high if freezing is meant to block all transfers. Profitability depends on attackers having prior approval, but it violates core security assumptions.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The function checks `frozenAccount[msg.sender]` (spender's status) instead of `frozenAccount[from]` (token owner's status). A frozen account (from) can still have its tokens transferred via an approved spender (msg.sender) as long as the spender is not frozen. This violates the intended freezing logic, allowing attackers to bypass account freezes by using approved addresses.",
        "code": "function transferFrom(address from, address to, uint value) returns (bool success) { if (frozenAccount[msg.sender]) return false; if(balances[from] < value) return false; if( allowed[from][msg.sender] >= value ) return false; if(balances[to] + value < balances[to]) return false; balances[from] -= value; allowed[from][msg.sender] -= value; balances[to] += value; Transfer(from, to, value); return true; }",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    },
    {
        "function_name": "approve",
        "vulnerability": "Unsafe ERC20 Approve",
        "criticism": "The reasoning is valid but overstates severity. The lack of a zero-reset check enables front-running, but this is a known ERC20 design flaw, not a code-specific bug. Severity is moderate (requires user error) and profitability is medium (depends on user behavior).",
        "correctness": 7,
        "severity": 5,
        "profitability": 5,
        "reason": "The `approve` function does not include a check for the front-running race condition. If a user changes their approval from a non-zero value to another non-zero value, an attacker can front-run the transaction to use the old approval before it is reset. While this is a known ERC20 design flaw, its presence here allows attackers to steal funds if users naively adjust approvals without first setting them to zero.",
        "code": "function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; }",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key."
    }
]