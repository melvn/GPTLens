[
    {
        "function_name": "approve",
        "vulnerability": "Non-standard ERC20 approve",
        "criticism": "The reasoning correctly identifies the ERC20 standard violation. By returning false when attempting to update a non-zero allowance, the function deviates from the ERC20 specification, which allows adjusting allowances from any value. This creates compatibility issues with contracts expecting standard behavior, enabling front-running attacks to lock approvals. However, the severity is reduced because modern UIs often handle allowance resets, and profitability depends on attacker ability to exploit front-running, which is situational. The direct financial impact is limited unless combined with other attack vectors.",
        "correctness": 8,
        "severity": 6,
        "profitability": 4,
        "reason": "The approve function returns false if attempting to update a non-zero allowance to another non-zero value, violating ERC20 standards. This prevents users from adjusting existing allowances without first resetting them to zero. Attackers can exploit this by front-running approval changes, causing transactions to fail or funds to be locked. Contracts expecting standard ERC20 behavior will misinterpret the false return value, leading to operational failures.",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) {\n    if (_value != 0 && allowed[msg.sender][_spender] != 0) {\n        return false;\n    }\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n}",
        "label": "Typo Constructor",
        "file_name": "2019-15078.sol",
        "description": "An issue was discovered in a smart contract implementation for AIRDROPX BORN through 2019-05-29, an Ethereum token. The name of the constructor has a typo (wrong case: XBornID versus XBORNID) that allows an attacker to change the owner of the contract and obtain cryptocurrency for free."
    },
    {
        "function_name": "onlyPayloadSize",
        "vulnerability": "Gas exhaustion via assert()",
        "criticism": "The analysis is accurate. Using assert() instead of require() creates gas-draining potential, as failed assertions consume all transaction gas. This could be weaponized in short-address attacks or malformed payloads. Severity is high due to the irreversible gas loss, but profitability requires attackers to trick users into initiating the transactions (e.g., via phishing). While dangerous, real-world exploitation requires social engineering, making direct profitability moderate. The correctness score is high as the code flaw is unambiguous.",
        "correctness": 9,
        "severity": 8,
        "profitability": 6,
        "reason": "The onlyPayloadSize modifier uses assert() to validate transaction payload size. Unlike require(), assert() consumes all gas on failure. Attackers can craft malformed transactions (e.g., short-address attacks) to trigger this assertion, forcing victims to waste all gas. This enables gas-draining attacks and disrupts user transactions, directly benefiting attackers by increasing operational costs.",
        "code": "modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length >= size + 4);\n    _;\n}",
        "label": "Typo Constructor",
        "file_name": "2019-15078.sol",
        "description": "An issue was discovered in a smart contract implementation for AIRDROPX BORN through 2019-05-29, an Ethereum token. The name of the constructor has a typo (wrong case: XBornID versus XBORNID) that allows an attacker to change the owner of the contract and obtain cryptocurrency for free."
    },
    {
        "function_name": "getTokens",
        "vulnerability": "ETH trapping with owner withdrawal",
        "criticism": "The reasoning is partially correct. While the function accepts ETH without processing it, the vulnerability assumes the existence of a withdraw() function (not shown). If withdrawal logic exists, trapped ETH could be stolen by the owner. Severity depends on the contract's ETH balance size and user awareness. Profitability requires active social engineering to trick users into sending ETH. The code flaw itself (payable without value handling) is severe, but exploitation requires external factors, lowering immediate risk.",
        "correctness": 7,
        "severity": 7,
        "profitability": 5,
        "reason": "The getTokens function is payable but does not process or validate msg.value. Users can accidentally send ETH, which remains trapped in the contract. The owner can withdraw these funds via withdraw(), creating a risk of financial loss for users. Attackers can also social-engineer victims into sending ETH, effectively stealing funds through the owner's withdrawal capability.",
        "code": "function getTokens() payable canDistr onlyWhitelist public {\n    if (value > totalRemaining) {\n        value = totalRemaining;\n    }\n    require(value <= totalRemaining);\n    address investor = msg.sender;\n    uint256 toGive = value;\n    distr(investor, toGive);\n    if (toGive > 0) {\n        blacklist[investor] = true;\n    }\n    if (totalDistributed >= totalSupply) {\n        distributionFinished = true;\n    }\n    value = value.div(100000).mul(99999);\n}",
        "label": "Typo Constructor",
        "file_name": "2019-15078.sol",
        "description": "An issue was discovered in a smart contract implementation for AIRDROPX BORN through 2019-05-29, an Ethereum token. The name of the constructor has a typo (wrong case: XBornID versus XBORNID) that allows an attacker to change the owner of the contract and obtain cryptocurrency for free."
    }
]